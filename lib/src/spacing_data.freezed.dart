// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'spacing_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$SleekSpacingDataTearOff {
  const _$SleekSpacingDataTearOff();

  _SleekSpacingData _(
      {@required double extraSmall,
      @required double small,
      @required double normal,
      @required double medium,
      @required double big,
      @required double extraBig}) {
    return _SleekSpacingData(
      extraSmall: extraSmall,
      small: small,
      normal: normal,
      medium: medium,
      big: big,
      extraBig: extraBig,
    );
  }
}

// ignore: unused_element
const $SleekSpacingData = _$SleekSpacingDataTearOff();

mixin _$SleekSpacingData {
  double get extraSmall;
  double get small;
  double get normal;
  double get medium;
  double get big;
  double get extraBig;

  $SleekSpacingDataCopyWith<SleekSpacingData> get copyWith;
}

abstract class $SleekSpacingDataCopyWith<$Res> {
  factory $SleekSpacingDataCopyWith(
          SleekSpacingData value, $Res Function(SleekSpacingData) then) =
      _$SleekSpacingDataCopyWithImpl<$Res>;
  $Res call(
      {double extraSmall,
      double small,
      double normal,
      double medium,
      double big,
      double extraBig});
}

class _$SleekSpacingDataCopyWithImpl<$Res>
    implements $SleekSpacingDataCopyWith<$Res> {
  _$SleekSpacingDataCopyWithImpl(this._value, this._then);

  final SleekSpacingData _value;
  // ignore: unused_field
  final $Res Function(SleekSpacingData) _then;

  @override
  $Res call({
    Object extraSmall = freezed,
    Object small = freezed,
    Object normal = freezed,
    Object medium = freezed,
    Object big = freezed,
    Object extraBig = freezed,
  }) {
    return _then(_value.copyWith(
      extraSmall:
          extraSmall == freezed ? _value.extraSmall : extraSmall as double,
      small: small == freezed ? _value.small : small as double,
      normal: normal == freezed ? _value.normal : normal as double,
      medium: medium == freezed ? _value.medium : medium as double,
      big: big == freezed ? _value.big : big as double,
      extraBig: extraBig == freezed ? _value.extraBig : extraBig as double,
    ));
  }
}

abstract class _$SleekSpacingDataCopyWith<$Res>
    implements $SleekSpacingDataCopyWith<$Res> {
  factory _$SleekSpacingDataCopyWith(
          _SleekSpacingData value, $Res Function(_SleekSpacingData) then) =
      __$SleekSpacingDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {double extraSmall,
      double small,
      double normal,
      double medium,
      double big,
      double extraBig});
}

class __$SleekSpacingDataCopyWithImpl<$Res>
    extends _$SleekSpacingDataCopyWithImpl<$Res>
    implements _$SleekSpacingDataCopyWith<$Res> {
  __$SleekSpacingDataCopyWithImpl(
      _SleekSpacingData _value, $Res Function(_SleekSpacingData) _then)
      : super(_value, (v) => _then(v as _SleekSpacingData));

  @override
  _SleekSpacingData get _value => super._value as _SleekSpacingData;

  @override
  $Res call({
    Object extraSmall = freezed,
    Object small = freezed,
    Object normal = freezed,
    Object medium = freezed,
    Object big = freezed,
    Object extraBig = freezed,
  }) {
    return _then(_SleekSpacingData(
      extraSmall:
          extraSmall == freezed ? _value.extraSmall : extraSmall as double,
      small: small == freezed ? _value.small : small as double,
      normal: normal == freezed ? _value.normal : normal as double,
      medium: medium == freezed ? _value.medium : medium as double,
      big: big == freezed ? _value.big : big as double,
      extraBig: extraBig == freezed ? _value.extraBig : extraBig as double,
    ));
  }
}

class _$_SleekSpacingData
    with DiagnosticableTreeMixin
    implements _SleekSpacingData {
  const _$_SleekSpacingData(
      {@required this.extraSmall,
      @required this.small,
      @required this.normal,
      @required this.medium,
      @required this.big,
      @required this.extraBig})
      : assert(extraSmall != null),
        assert(small != null),
        assert(normal != null),
        assert(medium != null),
        assert(big != null),
        assert(extraBig != null);

  @override
  final double extraSmall;
  @override
  final double small;
  @override
  final double normal;
  @override
  final double medium;
  @override
  final double big;
  @override
  final double extraBig;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SleekSpacingData._(extraSmall: $extraSmall, small: $small, normal: $normal, medium: $medium, big: $big, extraBig: $extraBig)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SleekSpacingData._'))
      ..add(DiagnosticsProperty('extraSmall', extraSmall))
      ..add(DiagnosticsProperty('small', small))
      ..add(DiagnosticsProperty('normal', normal))
      ..add(DiagnosticsProperty('medium', medium))
      ..add(DiagnosticsProperty('big', big))
      ..add(DiagnosticsProperty('extraBig', extraBig));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SleekSpacingData &&
            (identical(other.extraSmall, extraSmall) ||
                const DeepCollectionEquality()
                    .equals(other.extraSmall, extraSmall)) &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)) &&
            (identical(other.normal, normal) ||
                const DeepCollectionEquality().equals(other.normal, normal)) &&
            (identical(other.medium, medium) ||
                const DeepCollectionEquality().equals(other.medium, medium)) &&
            (identical(other.big, big) ||
                const DeepCollectionEquality().equals(other.big, big)) &&
            (identical(other.extraBig, extraBig) ||
                const DeepCollectionEquality()
                    .equals(other.extraBig, extraBig)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(extraSmall) ^
      const DeepCollectionEquality().hash(small) ^
      const DeepCollectionEquality().hash(normal) ^
      const DeepCollectionEquality().hash(medium) ^
      const DeepCollectionEquality().hash(big) ^
      const DeepCollectionEquality().hash(extraBig);

  @override
  _$SleekSpacingDataCopyWith<_SleekSpacingData> get copyWith =>
      __$SleekSpacingDataCopyWithImpl<_SleekSpacingData>(this, _$identity);
}

abstract class _SleekSpacingData implements SleekSpacingData {
  const factory _SleekSpacingData(
      {@required double extraSmall,
      @required double small,
      @required double normal,
      @required double medium,
      @required double big,
      @required double extraBig}) = _$_SleekSpacingData;

  @override
  double get extraSmall;
  @override
  double get small;
  @override
  double get normal;
  @override
  double get medium;
  @override
  double get big;
  @override
  double get extraBig;
  @override
  _$SleekSpacingDataCopyWith<_SleekSpacingData> get copyWith;
}
